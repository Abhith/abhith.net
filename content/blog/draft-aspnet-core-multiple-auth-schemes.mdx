---
title: ASP.NET Core - Using Mutliple Authentication Schemes
description: >-
  One endpoint, authorize using Identity Server or using a Custom AuthenticationHandler.
author: Abhith Rajan
authorURL: "https://twitter.com/abhithrajan"
date: 2019-09-22T19:26:00.000Z
image: /img/blog/c-sharp-get-last-n-characters-from-a-string.png
draft: true
tags:
  - c-sharp
---

In some occations, you might want your API to be authorized using multiple schemes. In my case, I had to allow one endpoint for authorized clients (using Identity Server) as well as using some custom token which is generated by a custom service for authorized users.

To achieve this, we need to create the custom AuthenticationScheme and configure a policy to use our custom scheme as well as JwtBearer.

## Custom AuthenticationScheme

By creating this, it will validate our custom token using the [Authorize] attribute.

Lets start with the defaults, where we describe the name of the scheme.

```cs

public static class CustomAuthenticationDefaults
{
    public const string AuthenticationScheme = "Custom";
}
```

Now `AuthenticationSchemeOptions`,

```cs
using Microsoft.AspNetCore.Authentication;

public class CustomAuthOptions : AuthenticationSchemeOptions
{
    public string UserInfoEndpoint { get; set; }
}

```

In order to validate the custom token, I need to sent an HTTP request and I need to get the HTTP endpoint from my configuration.
By defining `AuthenticationSchemeOptions`, we can pass value while setting up the scheme in the Startup.

Let's move on to `AuthenticationHandler`, which validates the token.

```cs

using Flurl.Http;
using Microsoft.AspNetCore.Authentication;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Security.Principal;
using System.Text.Encodings.Web;
using System.Threading.Tasks;
...


public class CustomAuthenticationHandler : AuthenticationHandler<CustomAuthOptions>
{
    public CustomAuthenticationHandler(
        IOptionsMonitor<CustomAuthOptions> options,
        ILoggerFactory logger,
        UrlEncoder encoder,
        ISystemClock clock
        )
        : base(options, logger, encoder, clock)
    {
    }

    protected override async Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        if (!Request.Headers.ContainsKey("Authorization"))
            return AuthenticateResult.Fail("Unauthorized");

        string authorizationHeader = Request.Headers["Authorization"];
        if (string.IsNullOrEmpty(authorizationHeader))
        {
            return AuthenticateResult.NoResult();
        }

        if (!authorizationHeader.StartsWith(CustomAuthenticationDefaults.AuthenticationScheme, StringComparison.OrdinalIgnoreCase))
        {
            return AuthenticateResult.Fail("Unauthorized");
        }

        string token = authorizationHeader.Substring(CustomAuthenticationDefaults.AuthenticationScheme.Length).Trim();

        if (string.IsNullOrEmpty(token))
        {
            return AuthenticateResult.Fail("Unauthorized");
        }

        try
        {
            return await ValidateTokenAsync(token);
        }
        catch (Exception ex)
        {
            return AuthenticateResult.Fail(ex.Message);
        }
    }

    private async Task<AuthenticateResult> ValidateTokenAsync(string session)
    {
        var user = await Options.UserInfoEndpoint
            .WithHeader("some-id", session)
            .GetJsonAsync<User>();

        if (user == null)
        {
            return AuthenticateResult.Fail("Unauthorized");
        }

        var userIdCredential = user.Credentials.FirstOrDefault(c => c.CredentialType == 0);

        var claims = new List<Claim>
        {
            new Claim("scope", Policy.Orders.Create),
            new Claim(ClaimTypes.NameIdentifier, userIdCredential.Credential)
        };

        var identity = new ClaimsIdentity(claims, Scheme.Name);
        var principal = new GenericPrincipal(identity, new[] { "user" });
        var ticket = new AuthenticationTicket(principal, Scheme.Name);
        return AuthenticateResult.Success(ticket);
    }
}
```

Now we need to configure our custom authentication,

```cs
public static IServiceCollection AddCustomAuthentication(this IServiceCollection services, IConfiguration configuration)
{

    // Identity Server Configuration
    var identityUrl = configuration.GetValue<string>("IdentityServerBaseUrl");
    services.AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
        options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    }).AddJwtBearer(options =>
    {
        options.Authority = identityUrl;
        options.RequireHttpsMetadata = false;
        options.Audience = "your_api";
    });

    // Custom Authentication configuration
    services.AddAuthentication(CustomAuthenticationDefaults.AuthenticationScheme)
        .AddScheme<CustomAuthOptions, CustomAuthenticationHandler>(CustomAuthenticationDefaults.AuthenticationScheme,
        o => o.UserInfoEndpoint = configuration.GetValue<string>("Authentication:Custom:UserInfoEndpoint"));

    // Authorization
    services.AddAuthorization(options =>
    {
        options.AddPolicy(Policy.Orders.Create, policy =>
        {
            policy.AuthenticationSchemes.Add(JwtBearerDefaults.AuthenticationScheme);
            policy.AuthenticationSchemes.Add(CustomAuthenticationDefaults.AuthenticationScheme);
            policy.RequireClaim("scope", Policy.Orders.Create);
        });
        //options.AddPolicy(Policy.Orders.Create, policy => policy.RequireClaim("scope", Policy.Orders.Create));
        options.AddPolicy(Policy.Orders.Read, policy => policy.RequireClaim("scope", Policy.Orders.Read));
    });

    return services;
}

```

Done, let's enable the multi authorization to our endpoint. In the controller action,

```cs
[Authorize(Policy = Policy.Orders.Create)]
public async Task<ActionResult<OrderResult>> CreateOrderAsync(OrderRequest orderRequest)
{
    var clientIdClaim = HttpContext.User.FindFirst("client_id"); // identity server client
    var userIdClaim = HttpContext.User.FindFirst(ClaimTypes.NameIdentifier); // user authenticated using custom auth handler.
    ...
}
```

And the configuration we added in the `appsettings.json`,

```json
"Authentication": {
    "Custom": {
      "UserInfoEndpoint": "https://yourcustomauthwebsite.com/userInfo"
    }
  }
```

Now we can invoke our create order endpoint with valid `bearer` token as well as with our custom token.

```
Authorization: <type> <credentials>
```

##

- [](https://joonasw.net/view/creating-auth-scheme-in-aspnet-core-2)
